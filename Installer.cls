Class %ZPM.Installer Extends %Projection.AbstractProjection
{

Projection Reference As Installer;

/// Version used for autoinstall release
Parameter VERSION;

/// Number of files for autoinstall release
Parameter FILESCOUNT = 0;

/// Application Definition
XData PM [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Default Name="MODDIR" Dir="${MGRDIR}zpm" />
<Default Name="SRCDIR" Dir="${MODDIR}src" />
<Default Name="REGISTRY" Value="https://pm.community.intersystems.com" />

<Namespace Name="%SYS">
  <Import File="${SRCDIR}inc/_ZPM/PackageManager/Common.inc" />
  <Import File="${SRCDIR}cls" Recurse="1" />
  
  <Invoke Class="%ZPM.PackageManager" Method="UpdateLanguageExtensions" />
  <Invoke Class="%ZPM.Installer" Method="ZPMInit">
    <Arg Value="${REGISTRY}"/>
  </Invoke>
  <Invoke Class="%ZPM.Installer" Method="ZPMLoad">
    <Arg Value="${MODDIR}"/>
  </Invoke>
  <Invoke Class="%ZPM.Installer" Method="ZPMCompile" />
</Namespace>

</Manifest>
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method. 
  Do %code.WriteLine(" If $Data(pVars, path)#10,path'="""" Set pVars(""MODDIR"")=path")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "PM")
}

ClassMethod ZPMInit(pRegistry As %String = "")
{
  if (pRegistry'="") {
    do ##class(%ZPM.PackageManager).Shell("repo -t registry -name registry -url "_ pRegistry)
  }
}

ClassMethod ZPMLoad(pDirectoryName)
{
  do ##class(%ZPM.PackageManager).Shell("load -dev "_pDirectoryName)
}

ClassMethod ZPMCompile()
{
  do ##class(%ZPM.PackageManager).Shell("ZPM compile")
}

ClassMethod CreateProjection(classname As %String, ByRef parameters As %String, modified As %String, qstruct) As %Status
{
  #; Behave as simple installer
  If (..#FILESCOUNT'>0)||(..#VERSION="") QUIT $$$OK

  #; This flag used in development
  if $DATA(^%ZPM("skipinstall")) QUIT $$$OK
  
  #; Installed version newer
  if '..NeedInstall() QUIT $$$OK

  Write !,"Extract package"
  Do ..ExtractPackage(.tModDir)
  
  Write !,"Install ZPM"

  set ts = $ZHOROLOG
  set logFile=##class(%File).TempFilename()
  JOB ..setup(tModDir, 3):(:::logFile):0
  if '$test {
    quit $$$OK
  }
  #; Wait setup
  set child=$zchild
  do { hang 0.1 } while $data(^$JOB(child)) 

  set fs=##class(%Stream.FileCharacter).%New()
  set fs.Filename=logFile
  while 'fs.AtEnd {
    write !,fs.ReadLine()
  }
  if ##class(%File).Delete(logFile)

  Write !,"Time spent ",$ZHOROLOG - ts

  QUIT $$$OK
}

/// Check currently installed version, if any
ClassMethod NeedInstall(Output version As %String)
{
  try {
    set module = ##class(%ZPM.PackageManager.Developer.Module).NameOpen("zpm")
    if '$ISOBJECT(module) {
      RETURN 1
    }

    set version = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(..#VERSION)
    if $isobject(version) {
      RETURN version.Follows(module.Version)
    }

  } CATCH ex {
    
  }
  QUIT 1
}

ClassMethod Make(pPackage As %Stream.Object, ByRef pStream As %Stream.TmpCharacter) As %Status
{
  Set tSC = $$$OK
  try {
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen("zpm")

    Set tmpDir = ##class(%File).NormalizeDirectory($$$FileTempDir)
    $$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Archive).Extract(pPackage, tmpDir))

    Do ..CollectPackage(tmpDir, .tList, tmpDir)

    Do ..CompactPackage(.tList)

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||VERSION")
    Set param.Default = tModule.VersionString
    Do param.%Save()

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||FILESCOUNT")
    Set param.Default = $Get(tList)
    Do param.%Save()

    Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", .pStream, "/diffexport/exportversion=2017.1")
    #; Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", , "/diffexport/exportversion=2017.1")
  } Catch e {
    Set tSC = e.AsStatus()
  }
  QUIT tSC
}

ClassMethod CollectPackage(pPath As %String, Output pList, pRoot As %String)
{
  set rs = ##class(%File).FileSetFunc(pPath)
  WHILE rs.%Next() {
    If rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } ELSE {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name) 
      Set pList($INCREMENT(pList)) = $LISTBUILD(rs.Name, $EXTRACT(rs.Name, $LENGTH(pRoot) + 1, *))
    }
  }
}

ClassMethod CompactPackage(ByRef pList) As %Status
{
  set file = ""
  for i=1:1:$Get(pList) {
    Set $LISTBUILD(file, name) = pList(i)
    
    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    Set gzip = ##class(%Stream.FileBinaryGzip).%New()
    Set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)
    
    Set gzip = ##class(%Stream.FileBinary).%New()
    Set gzip.Filename = tmpFile

    Set xdata = ##class(%Dictionary.XDataDefinition).%New()
    Set xdata.Name = "Data"_i
    Set xdata.Description = name
    Do xdata.parentSetObjectId($CLASSNAME())
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $SYSTEM.Encryption.Base64Encode(data)
      do xdata.Data.WriteLine(base64)
      set data1 = $SYSTEM.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $SYSTEM.Encryption.SHA1HashStream(gzip)
  
    do ##class(%File).Delete(tmpFile)
  }
  QUIT $$$OK
  
  
  Quit $$$OK
}

ClassMethod ExtractPackage(Output pFolder As %String) As %String
{
  Set pFolder = ##class(%File).NormalizeDirectory($$$FileTempDir)

  For i=1:1:..#FILESCOUNT {
    Set xdata = ##class(%Dictionary.XDataDefinition).%OpenId($CLASSNAME()_"||Data"_i)
    Set name = xdata.Description
    Set fileName = pFolder_name

    Set tParentFolder = ##class(%File).ParentDirectoryName(fileName)    
    if '##class(%File).DirectoryExists(tParentFolder) {
      Do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $ZSTRIP(data, "*C")
      set prev = $EXTRACT(data, chunkSize + 1, *)
      set data = $EXTRACT(data, 1, chunkSize)
      set chunk = $SYSTEM.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    set fs = ##class(%Stream.FileCharacter).%New()
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  Quit $$$OK
}

}
